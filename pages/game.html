---
layout: default
title: Joguinho zuado
logo: 'assets/images/logo.png'
---
<header class="main-header post-head {% if page.cover %}" style="background-image: url({{ site.baseurl }}{{ page.cover }}){% else %}no-cover{% endif %}">
    <nav class="main-nav {% if page.cover %}overlay{% endif %} clearfix">
        {% if page.logo %}<a class="blog-logo" href="{{ site.baseurl }}"><img src="{{ site.baseurl }}{{ page.logo }}" alt="Blog Logo" /></a>{% endif %}
        {% if page.navigation %}
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
            {{ include navigation.html }}
        {% endif %}
    </nav>
</header>

<!--==========================================================================

Esse jogo foi feito com base no tutorial do Raining Chain. Veja mais vÃ­deos no canal dele: https://www.youtube.com/channel/UC8Yp-YagXZ4C5vOduEhcjRw
===========================================================================-->
<body><center>
<canvas id="ctx" width="1080" height="500" style="border:1px solid #000000;">
</canvas>
</center>
<script>
var ctx = document.getElementById("ctx").getContext("2d");

// 1. Modify Settings
ctx.font = '30px Arial';	// Font used
ctx.fillStyle = 'black';		// Color of the text and forms
// ctx.globalAlpha = 0.5;		// Transparency 0 = invisible, 1 = visible

// 2. Drawing entity
ctx.fillText('Player', 50, 50);

// 3. Animation

var heightCanvas = 500;
var widthCanvas = 500;
var timeWhenGameStarted = Date.now(); // return time in ms

var frameCount = 0;
var score = 0;

// player
var player;

Player = function(){
	var self = Actor('player', 'myId', 50, 40, 30, 5, 20, 20, 'green', 10, 1);
	self.updatePosition = function(){
		console.log("Entrou aqui");
        if(self.pressingRight)
            self.x += 10;
        if(self.pressingLeft)
            self.x -= 10;  
        if(self.pressingDown)
            self.y += 10;  
        if(self.pressingUp)
            self.y -= 10;  
       
        //is position valid
        if(self.x < self.width/2)
            self.x = self.width/2;
        if(self.x > widthCanvas-self.width/2)
            self.x = widthCanvas - self.width/2;
        if(self.y < self.height/2)
            self.y = self.height/2;
        if(self.y > heightCanvas - self.height/2)
            self.y = heightCanvas - self.height/2;
    }

	self.pressingRight = false;
	self.pressingDown = false;
	self.pressingLeft = false;
	self.pressingUp = false;
	return self;
	
}

Entity = function(type, id, x, y, spdX, spdY, width, height, color){
    var self = {
        type: type,
        x: x,
        spdX: spdX,
        y: y,
        spdY: spdY,
        width: width,
        height: height,
        color: color,
    };

    self.update = function(){
        self.updatePosition();
        self.draw();
    }

    self.updatePosition = function(){    
        self.x += self.spdX;
        self.y += self.spdY;
                       
        if(self.x < 0 || self.x > widthCanvas){
            self.spdX = -self.spdX;
        }
        if(self.y < 0 || self.y > heightCanvas){
            self.spdY = -self.spdY;
        }
    
    }

    self.getDistance = function (entity2){  //return distance (number)
        var vx = self.x - entity2.x;
        var vy = self.y - entity2.y;
        return Math.sqrt(vx*vx+vy*vy);
    }
  
    self.testCollision = function(entity2){ //return if colliding (true/false)
        var rect1 = {
            x:self.x-self.width/2,
            y:self.y-self.height/2,
            width:self.width,
            height:self.height,
        }
        var rect2 = {
            x:entity2.x-entity2.width/2,
            y:entity2.y-entity2.height/2,
            width:entity2.width,
            height:entity2.height,
        }
        return testCollisionRectRect(rect1,rect2);
    }

    self.draw = function(){
        ctx.save();
        ctx.fillStyle = self.color;
        ctx.fillRect(self.x-self.width/2,self.y-self.height/2,self.width,self.height);
        ctx.restore();
    }
   
    return self;
}

Actor = function(type, id, x, y, spdX, spdY, width, height, color){
    var self = Entity(type,id,x,y,spdX,spdY,width,height,color);
   
    self.attackCounter = 0;
    self.aimAngle = 0;
    self.atkSpd = 1;
   
    self.performAttack = function(){
        if(self.attackCounter > 25){    //every 1 sec
            self.attackCounter = 0;
            generateBullet(self);
        }
    }

    self.performSpecialAttack = function(){
        if(self.attackCounter > 50){    //every 1 sec
            self.attackCounter = 0;
            
            for(var i = 0 ; i < 360; i += 10){
                generateBullet(self,i);
            }
        }
    }

    return self;
}



Enemy = function(id, x, spdX, y, spdY, width, height){
	var self = Actor('enemy', id, x, y, spdX, spdY, width, height, 'red');
	enemyList[id] = self;
}

Upgrade = function(id, x, spdX, y, spdY, width, height, category, color){
	var self = Entity('upgrade', id, x, y, spdX, spdY, width, height, color);
	self.category = category;
	upgradeList[id] = self;	
}

Bullet = function(id, x, spdX, y, spdY, width, height){
	var self = Entity('bullet', id, x, y, spdX, spdY, width, height, 'black');
	self.timer = 0;
	bulletList[id] = self;	
}

// lists
var upgradeList = {};
var bulletList = {};
var enemyList = {};

testCollisionRectRect = function (rect1, rect2) {
	return 	rect1.x <= rect2.x + rect2.width
		&&	rect2.x <= rect1.x + rect1.width
		&&	rect1.y <= rect2.y + rect2.height
		&&	rect2.y <= rect1.y + rect1. height;
}

document.onclick = function(mouse){
        player.performAttack();
}
 
document.oncontextmenu = function(mouse){
        player.performSpecialAttack();
        mouse.preventDefault();
}
 
document.onmousemove = function(mouse){
        var mouseX = mouse.clientX - document.getElementById('ctx').getBoundingClientRect().left;
        var mouseY = mouse.clientY - document.getElementById('ctx').getBoundingClientRect().top;
       
        mouseX -= player.x;
        mouseY -= player.y;
       
        player.aimAngle = Math.atan2(mouseY,mouseX) / Math.PI * 180;
}
 
document.onkeydown = function(event){
        if(event.keyCode === 68)        //d
                player.pressingRight = true;
        else if(event.keyCode === 83)   //s
                player.pressingDown = true;
        else if(event.keyCode === 65) //a
                player.pressingLeft = true;
        else if(event.keyCode === 87) // w
                player.pressingUp = true;
}
 
document.onkeyup = function(event){
        if(event.keyCode === 68)        //d
                player.pressingRight = false;
        else if(event.keyCode === 83)   //s
                player.pressingDown = false;
        else if(event.keyCode === 65) //a
                player.pressingLeft = false;
        else if(event.keyCode === 87) // w
                player.pressingUp = false;
}

startNewGame = function () {
	player.hp = 20;
	timeWhenGameStarted = Date.now();
	frameCount = 0;
	score = 0;
	enemyList = {};
	upgradeList = {};
	bulletList = {};
	randomlyGenerateEnemy();
	randomlyGenerateEnemy();
	randomlyGenerateEnemy();
}

update = function(){
	ctx.clearRect(0, 0, widthCanvas + 1000, heightCanvas + 100);
	
	frameCount++;
	player.attackCounter += player.atkSpd;
	score++;

	player.update();

	if(frameCount % 100 === 0){
		randomlyGenerateEnemy(); // after every 4 sec
	} 
	
	if(frameCount % 75 === 0){
		randomlyGenerateUpgrade(); // after every 3 sec
	}

	for(var key in bulletList){
		bulletList[key].update();
		bulletList[key].timer++;
		if(bulletList[key].timer > 100){
			delete bulletList[key];
			continue; // o loop acaba aqui e vai para o key++;
		}
		for(var key2 in enemyList){
			var isColliding = bulletList[key].testCollision(enemyList[key2]);

			if(isColliding){

				delete bulletList[key];
				delete enemyList[key2];
				break;
			}
		}
	}

	for(var key in upgradeList){
		upgradeList[key].update();
		var isColliding = player.testCollision(upgradeList[key]);
		if(isColliding){
			if(upgradeList[key].category === 'score')
				score += 1000;
			if(upgradeList[key].category === 'atkSpd'){
				player.atkSpd += 3;
				console.log("poder " + player.atkSpd);
			}
			delete upgradeList[key];
		}
	}

	for(var key in enemyList){
		enemyList[key].update();
		var isColliding = player.testCollision(enemyList[key]);
		if(isColliding){
			console.log('is Colliding');
			player.hp -= 1;
		}
	}
	if(player.hp <= 0){
		// player morreu
		var timeSurvived = Date.now() - timeWhenGameStarted;
		console.log("YOU SURVIVED FOR " + timeSurvived + "ms.");
		startNewGame();
	}

	ctx.fillText(player.hp + " HP", 0, 30);
	ctx.fillText("Score: " + score, 200, 30);
}

randomlyGenerateEnemy = function (){
	var x = Math.random() * widthCanvas;
	var y = Math.random() * heightCanvas;
	var height = 10 + Math.random() * 30;
	var width = 10 + Math.random() * 30;
	var id = Math.random();
	var spdX = 5 + Math.random() * 5;
	var spdY = 5 + Math.random() * 5;
	Enemy(id, x, spdX, y, spdY, width, height);
}

randomlyGenerateUpgrade = function (){
	var x = Math.random() * widthCanvas;
	var y = Math.random() * heightCanvas;
	var height = 10;
	var width = 10;
	var id = Math.random();
	var spdX = 0;
	var spdY = 0;
	if(Math.random() < 0.5){
		var category = 'score';

		var color = 'orange';
	}else {
		var category = 'atkSpd';
		var color = 'purple'; 
	}

	Upgrade(id, x, spdX, y, spdY, width, height, category, color);
}

generateBullet = function (actor, overwriteAngle){
	var x = actor.x;
	var y = actor.y;
	var height = 10;
	var width = 10;
	var id = Math.random();
	var angle = actor.aimAngle;
	if(overwriteAngle != undefined){
		angle = overwriteAngle;
	}
	var spdX = Math.cos(angle/180*3.14)*5;
	var spdY = Math.sin(angle/180*3.14)*5;
	Bullet(id, x, spdX, y, spdY, width, height);
}

player = Player();
startNewGame();
setInterval(update, 40);

</script>
</body>